<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Commander Token Board</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="TokenBoard">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#181818">

  <style>
    :root {
      --bg-dark: #111;
      --bg-panel: #181818;
      --border: #333;
      --accent: #2f7d32;
      --safe-top: env(safe-area-inset-top, 20px);
      --safe-bottom: env(safe-area-inset-bottom, 20px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }
    * { -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-dark); color: #eee; display: flex; flex-direction: column;
      height: 100vh; overflow: hidden; -webkit-user-select: none; user-select: none;
      padding-top: 0; padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left); padding-right: var(--safe-right);
    }

    input, select, textarea {
      font-size: 16px !important; padding: 12px; border-radius: 6px;
      border: 1px solid #444; background: #222; color: #eee; width: 100%; box-sizing: border-box; margin-bottom: 10px;
    }
    input:focus, select:focus, textarea:focus { outline: 2px solid #555; border-color: transparent; }

    button {
      background: #444; color: #eee; border: none; padding: 12px 16px; border-radius: 6px;
      cursor: pointer; font-size: 16px; font-weight: 500; touch-action: manipulation;
    }
    button:active { transform: scale(0.98); }
    button:disabled { opacity: 0.5; pointer-events: none; }

    .btn-green { background: var(--accent); color: white; width: 100%; font-weight: bold; }

    header {
      background: var(--bg-panel); border-bottom: 1px solid var(--border);
      display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
      z-index: 2000; position: relative;
      padding-top: calc(var(--safe-top) + 10px); padding-bottom: 15px;
      padding-left: 20px; padding-right: 20px; min-height: 60px;
    }
    header h1 { font-size: 22px; margin: 0; font-weight: 800; letter-spacing: 0.5px; display: flex; align-items: baseline; gap: 8px; }
    .version-tag { font-size: 12px; color: #666; font-weight: 400; }
    #menuBtn { background: transparent; border: 1px solid #444; font-size: 24px; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; padding: 0; border-radius: 8px; }

    #main-menu {
      display: none; position: absolute; top: calc(var(--safe-top) + 65px); right: 10px; background: #222;
      border: 1px solid #444; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.95);
      z-index: 3000; min-width: 240px; overflow: hidden;
    }
    .menu-item { display: block; padding: 18px 20px; color: #eee; text-decoration: none; border-bottom: 1px solid #333; font-size: 16px; cursor: pointer; }
    .menu-item:active { background: #333; }

    main { display: flex; flex: 1; overflow: hidden; position: relative; }
    main.maximize .sidebar { display: none !important; }
    .sidebar {
      width: 320px; background: #151515; border-right: 1px solid var(--border);
      display: flex; flex-direction: column; overflow-y: auto; padding: 16px; gap: 16px;
      flex-shrink: 0; -webkit-overflow-scrolling: touch;
    }
    .battlefield { flex: 1; padding: 16px; overflow-y: auto; background: #0a0a0a; -webkit-overflow-scrolling: touch; }
    .panel { background: var(--bg-panel); border-radius: 12px; padding: 16px; border: 1px solid var(--border); }
    h2 { margin: 0 0 12px; font-size: 14px; color: #888; text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
    .accordion-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 4px 0; }
    #customContent { margin-top: 16px; display: none; }

    /* SPLASH SCREEN */
    #splash-overlay {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.92); z-index: 6000;
        align-items: center; justify-content: center;
        padding: 20px; box-sizing: border-box; backdrop-filter: blur(8px);
    }
    .splash-content {
        background: #222; border: 1px solid #444; border-radius: 16px;
        padding: 30px; text-align: center; max-width: 400px; width: 100%;
        box-shadow: 0 20px 50px rgba(0,0,0,1);
        animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .splash-content h2 { color: var(--accent); margin-top: 0; font-size: 24px; }
    .splash-content p { color: #ccc; line-height: 1.6; font-size: 16px; margin-bottom: 25px; }
    .splash-icon { font-size: 40px; margin-bottom: 10px; display: block; }

    .modal-overlay {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); z-index: 5000; align-items: center; justify-content: center;
        padding: 20px; box-sizing: border-box; backdrop-filter: blur(5px);
    }
    .modal { background: #222; padding: 24px; border-radius: 12px; width: 100%; max-width: 500px; border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }

    .preset-picker { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; max-height: 250px; overflow-y: auto; }
    .preset-item {
      display: flex; align-items: center; gap: 10px; padding: 12px; background: #222;
      border-radius: 8px; cursor: pointer; font-size: 14px; border: 1px solid transparent; touch-action: manipulation;
    }
    .preset-item:active { background: #333; transform: scale(0.98); }

    #tokenList { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 16px; padding-bottom: 80px; }
    .token {
      position: relative; aspect-ratio: 5/7; border-radius: 12px; border: 2px solid transparent;
      padding: 6px; display: flex; flex-direction: column; background: #222;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5); touch-action: manipulation;
    }
    .token.tapped { transform: rotate(5deg) translateY(10px); opacity: 0.7; filter: grayscale(0.5); }
    .token.shake { animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake {
      10%, 90% { transform: translate3d(-2px, 0, 0); }
      20%, 80% { transform: translate3d(4px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
      40%, 60% { transform: translate3d(6px, 0, 0); }
    }

    .token-img-container {
      flex: 1; background: rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; margin-bottom: 8px;
      display: flex; align-items: center; justify-content: center; position: relative; border: 1px solid rgba(255,255,255,0.1);
    }
    /* LAYERS */
    .token-art-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-size: cover; background-position: center; background-repeat: no-repeat;
        z-index: 2; border-radius: 4px;
    }
    .token-text-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; align-items: center; justify-content: center;
        z-index: 1; font-size: 40px; color: rgba(255,255,255,0.2); font-weight: 800;
    }

    .token-details { display: flex; justify-content: space-between; align-items: center; font-size: 14px; font-weight: 600; height: 28px; }
    .token-qty { font-size: 14px; color: #fff; background: rgba(0,0,0,0.7); padding: 2px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); }
    .token-actions { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-top: 4px; }
    .token-actions button { padding: 8px 0; font-size: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: #ccc; }
    .token-actions button:hover { background: rgba(255,255,255,0.1); }
    .token-actions button.buff { color: #8f8; }
    .token-actions button.nerf { color: #f88; }

    .badge { position: absolute; padding: 4px 8px; border-radius: 6px; font-size: 11px; font-weight: bold; text-transform: uppercase; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.8); }
    .pt-badge { bottom: 6px; right: 6px; background: rgba(0,0,0,0.9); border: 1px solid #999; font-size: 16px; color: #fff; }
    .haste-badge { bottom: 6px; left: 6px; background: rgba(200,50,50,0.9); border: 1px solid red; color: #fff; }
    .sick-badge { top: 6px; right: 6px; background: rgba(180,180,0,0.9); border: 1px solid yellow; color: #fff; }

    .keyword-badge {
        top: 6px; left: 6px;
        background: rgba(0,0,0,0.85); border: 1px solid #555;
        color: #adf; padding: 2px 4px; font-size: 9px;
        display: flex; flex-direction: column; gap: 2px;
        align-items: flex-start;
        box-shadow: none; border-radius: 4px;
        max-height: 80%; overflow: hidden;
    }

    #fabNextTurn {
        position: fixed; bottom: calc(20px + var(--safe-bottom)); right: calc(20px + var(--safe-right));
        background: var(--accent); color: white; padding: 14px 24px; border-radius: 50px; font-weight: bold;
        box-shadow: 0 4px 15px rgba(0,0,0,0.6); z-index: 1000; border: 1px solid rgba(255,255,255,0.2);
        display: none; align-items: center; gap: 8px; font-size: 16px; transition: transform 0.2s, opacity 0.2s;
    }
    #fabNextTurn:active { transform: scale(0.95); }
    #fabNextTurn.visible { display: flex; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    @keyframes popIn { from { opacity: 0; transform: scale(0.5) translateY(20px); } to { opacity: 1; transform: scale(1) translateY(0); } }

    #toast {
        position: fixed; bottom: calc(30px + var(--safe-bottom)); left: 50%; transform: translateX(-50%);
        background: #333; color: white; padding: 12px 24px; border-radius: 30px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.8); z-index: 5000;
        display: flex; gap: 15px; align-items: center;
        opacity: 0; pointer-events: none; transition: opacity 0.3s;
        border: 1px solid #555;
    }
    #toast.show { opacity: 1; pointer-events: auto; }
    #toast button { background: transparent; border: 1px solid #777; padding: 4px 12px; font-size: 12px; margin: 0; }

    #context-menu {
      position: absolute; display: none; background: #222; border: 1px solid #555;
      border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.9); z-index: 4000; min-width: 200px;
    }

    .token[data-color="white"] { background: #545450; border-color: #a8a8a0; }
    .token[data-color="blue"] { background: #1d3a5e; border-color: #4a86c0; }
    .token[data-color="black"] { background: #2e2e2e; border-color: #5e5e5e; }
    .token[data-color="red"] { background: #5e1d1d; border-color: #c04a4a; }
    .token[data-color="green"] { background: #1d4a1d; border-color: #4ac04a; }
    .token[data-color="gold"] { background: #5e4b1d; border-color: #d4af37; }
    .token[data-color="colorless"] { background: #444444; border-color: #888888; }

    @media (max-width: 768px) {
      main { flex-direction: column; }
      .sidebar { width: 100%; max-height: 40vh; border-right: none; border-bottom: 1px solid var(--border); box-sizing: border-box; }
      #tokenList { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
    }
  </style>
</head>
<body>

<header>
  <h1>Commander Tokens <span class="version-tag">v4.6</span></h1>
  <button id="menuBtn">‚ò∞</button>
</header>

<div id="main-menu">
    <div class="menu-item" id="menuAddDeck" style="font-weight:bold; color:var(--accent);">+ Add Deck</div>
    <div class="menu-item" id="menuDefaultList">Restore Default List</div>
    <div style="border-bottom:1px solid #333; margin:4px 0;"></div>
    <a href="https://github.com/rcooperkaty/mtg-token-board/blob/main/README.md" target="_blank" class="menu-item">Instructions</a>
    <div class="menu-item" id="menuToggleSidebar">Hide Sidebar</div>
    <div class="menu-item" id="menuNextTurn">Untap / Next Turn</div>
    <div class="menu-item" style="color:#ff6b6b;" id="menuReset">Reset Board</div>
</div>

<div id="splash-overlay">
    <div class="splash-content">
        <span class="splash-icon">üÉè</span>
        <h2>Streamline Your Board</h2>
        <p>Want <b>just the tokens</b> for your specific deck?</p>
        <p>Open the <b>Menu (‚ò∞)</b> and select <b style="color:var(--accent)">+ Add Deck</b> to import your decklist automatically!</p>
        <button id="splash-dismiss" class="btn-green">Got it!</button>
    </div>
</div>

<div class="modal-overlay" id="deckModal">
    <div class="modal">
        <h2 style="color:#eee; margin-top:0;">Import Deck</h2>
        <p style="font-size:14px; color:#aaa; margin-bottom:12px; line-height:1.4;">Paste your decklist. We will parse it for Token Names and Stats only.</p>
        <textarea id="deckInput" placeholder="1 Sol Ring&#10;1 Rhys the Redeemed&#10;..."></textarea>
        <div id="importStatus" style="font-size:13px; color:#888; font-style:italic; margin-bottom:10px;"></div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
            <button onclick="closeDeckModal()" style="background:#333;">Cancel</button>
            <button onclick="processDeckImport()" class="btn-green" style="width:auto;">Import</button>
        </div>
    </div>
</div>

<div id="toast">
    <span id="toastMsg">Action</span>
    <button id="toastUndo">UNDO</button>
</div>

<main>
  <div class="sidebar">
    <div class="panel">
      <h2>Quick Add</h2>
      <input id="presetSearch" type="text" placeholder="Start typing to find tokens..." />
      <div id="presetPicker" class="preset-picker"></div>
    </div>

    <div class="panel" id="customPanel">
      <h2 id="customHeader" class="accordion-header">
        <span>Custom Token</span>
        <span id="customArrow">‚ñ∂</span>
      </h2>
      <div id="customContent">
          <form id="tokenForm">
            <input type="text" id="name" placeholder="Name" required />
            <div style="display:flex; gap:10px;">
              <input type="number" id="qty" value="1" min="1" placeholder="Qty" style="flex:1" />
              <select id="color" style="flex:1">
                <option value="white">White</option>
                <option value="blue">Blue</option>
                <option value="black">Black</option>
                <option value="red">Red</option>
                <option value="green">Green</option>
                <option value="gold">Gold</option>
                <option value="colorless">Colorless</option>
              </select>
            </div>
            <div style="display:flex; gap:10px;">
              <input type="number" id="power" value="1" placeholder="Pow" style="flex:1" />
              <input type="number" id="toughness" value="1" placeholder="Tgh" style="flex:1" />
            </div>
            <input type="file" id="image" accept="image/*" style="padding:10px; font-size:14px;" />

            <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:15px;">
                <label style="font-size:16px; display:flex; align-items:center; gap:10px; cursor:pointer">
                  <input type="checkbox" id="haste" style="width:24px; height:24px; margin:0;"> Creature has Haste
                </label>
                <label style="font-size:16px; display:flex; align-items:center; gap:10px; cursor:pointer; color:#8df;">
                  <input type="checkbox" id="isCardCopy" style="width:24px; height:24px; margin:0;"> Search Real Card?
                </label>
            </div>

            <button type="submit" class="btn-green" id="createBtn">Create Token</button>
          </form>
      </div>
    </div>
  </div>

  <div class="battlefield">
    <div id="tokenList"></div>
    <button id="fabNextTurn">Next Turn ‚Ü∫</button>
  </div>
</main>

<div id="context-menu"></div>

<script>
  let wakeLock = null;
  async function requestWakeLock() { if ('wakeLock' in navigator) try { wakeLock = await navigator.wakeLock.request('screen'); } catch (e){} }
  document.addEventListener('visibilitychange', async () => { if (wakeLock !== null && document.visibilityState === 'visible') requestWakeLock(); });
  requestWakeLock();

  // --- SPLASH SCREEN LOGIC ---
  const SPLASH_KEY = "tokenboard_splash_v1";
  if (!localStorage.getItem(SPLASH_KEY)) {
      document.getElementById("splash-overlay").style.display = "flex";
  }
  document.getElementById("splash-dismiss").onclick = () => {
      document.getElementById("splash-overlay").style.display = "none";
      localStorage.setItem(SPLASH_KEY, "true");
  };

  const DEFAULT_PRESETS = {
    angel:        { name: "Angel",        color: "white",     power: 4, toughness: 4 },
    beast:        { name: "Beast",        color: "green",     power: 3, toughness: 3 },
    bird:         { name: "Bird",         color: "blue",      power: 1, toughness: 1 },
    cat:          { name: "Cat",          color: "white",     power: 2, toughness: 2 },
    clue:         { name: "Clue",         color: "colorless", power: 0, toughness: 0 },
    construct:    { name: "Construct",    color: "colorless", power: 0, toughness: 0 },
    demon:        { name: "Demon",        color: "black",     power: 5, toughness: 5 },
    dragon:       { name: "Dragon",       color: "red",       power: 4, toughness: 4 },
    drake:        { name: "Drake",        color: "blue",      power: 2, toughness: 2 },
    elf:          { name: "Elf Warrior",  color: "green",     power: 1, toughness: 1 },
    food:         { name: "Food",         color: "colorless", power: 0, toughness: 0 },
    goblin:       { name: "Goblin",       color: "red",       power: 1, toughness: 1 },
    golem:        { name: "Golem",        color: "colorless", power: 3, toughness: 3 },
    human:        { name: "Human",        color: "white",     power: 1, toughness: 1 },
    insect:       { name: "Insect",       color: "green",     power: 1, toughness: 1 },
    knight:       { name: "Knight",       color: "white",     power: 2, toughness: 2 },
    myr:          { name: "Myr",          color: "colorless", power: 1, toughness: 1 },
    pegasus:      { name: "Pegasus",      color: "white",     power: 1, toughness: 1 },
    plant:        { name: "Plant",        color: "green",     power: 0, toughness: 1 },
    rat:          { name: "Rat",          color: "black",     power: 1, toughness: 1 },
    saproling:    { name: "Saproling",    color: "green",     power: 1, toughness: 1 },
    soldier:      { name: "Soldier",      color: "white",     power: 1, toughness: 1 },
    spirit:       { name: "Spirit",       color: "white",     power: 1, toughness: 1 },
    thopter:      { name: "Thopter",      color: "colorless", power: 1, toughness: 1 },
    treasure:     { name: "Treasure",     color: "colorless", power: 0, toughness: 0 },
    wolf:         { name: "Wolf",         color: "green",     power: 2, toughness: 2 },
    zombie:       { name: "Zombie",       color: "black",     power: 2, toughness: 2 }
  };

  let activePresets = { ...DEFAULT_PRESETS };
  let suggestedTokens = [];
  let editingTokenId = null;

  const menuBtn = document.getElementById("menuBtn");
  const mainMenu = document.getElementById("main-menu");
  menuBtn.onclick = (e) => { e.stopPropagation(); mainMenu.style.display = mainMenu.style.display === "block" ? "none" : "block"; };
  document.addEventListener("click", (e) => { if (!e.target.closest("#main-menu") && e.target !== menuBtn) mainMenu.style.display = "none"; });

  document.getElementById("menuToggleSidebar").onclick = () => { document.querySelector("main").classList.toggle("maximize"); mainMenu.style.display = "none"; };
  document.getElementById("menuNextTurn").onclick = () => { handleNextTurn(); mainMenu.style.display = "none"; };
  document.getElementById("menuReset").onclick = () => { if(confirm("Clear board?")) { tokens = []; sessionImages = {}; save(); render(); } mainMenu.style.display = "none"; };
  document.getElementById("menuDefaultList").onclick = () => { activePresets = { ...DEFAULT_PRESETS }; suggestedTokens = []; renderPresets(""); mainMenu.style.display = "none"; };
  document.getElementById("menuAddDeck").onclick = () => { document.getElementById("deckModal").style.display = "flex"; document.getElementById("deckInput").focus(); mainMenu.style.display = "none"; };
  function closeDeckModal() { document.getElementById("deckModal").style.display = "none"; document.getElementById("importStatus").innerText = ""; }

  let lastDeletedState = null;
  function showToast(msg, undoCallback) {
      const t = document.getElementById("toast");
      const msgEl = document.getElementById("toastMsg");
      const btn = document.getElementById("toastUndo");
      msgEl.innerText = msg;
      t.classList.add("show");
      if (undoCallback) { btn.style.display = 'block'; btn.onclick = () => { undoCallback(); t.classList.remove("show"); }; }
      else { btn.style.display = 'none'; }
      setTimeout(() => { t.classList.remove("show"); }, 4000);
  }

  // --- AUTO-FETCHER (Strict Search) ---
  async function fetchTokenArt(tokenId, tokenName, isCard) {
      if (!tokenName) return;
      const cleanName = tokenName.trim();
      // Only fetch if it's a "Real Card". Tokens use local or text.
      if (!isCard) return;

      const query = `!"${encodeURIComponent(cleanName)}"`;
      const searchUrl = `https://api.scryfall.com/cards/search?q=${query}&unique=art`;

      try {
          const resp = await fetch(searchUrl);
          const data = await resp.json();
          if (data.data && data.data.length > 0) {
              const card = data.data[0];
              let newUrl = null;
              if (card.image_uris && card.image_uris.art_crop) newUrl = card.image_uris.art_crop;
              else if (card.card_faces && card.card_faces[0].image_uris) newUrl = card.card_faces[0].image_uris.art_crop;

              if (newUrl) {
                  const target = tokens.find(t => t.id === tokenId);
                  if (target) {
                      target.scryfallUrl = newUrl;
                      save(); render();
                  }
              }
          } else {
              showToast(`Card not found: "${cleanName}"`, null);
          }
      } catch (e) { console.log("Fetch failed"); }
  }

  async function processDeckImport() {
    const rawText = document.getElementById("deckInput").value;
    const statusEl = document.getElementById("importStatus");
    if(!rawText.trim()) return;
    statusEl.innerText = "Parsing...";
    const lines = rawText.split('\n');
    const cardNames = lines.map(line => line.replace(/^\d+x?\s+/, "").split("(")[0].trim()).filter(n => n.length > 0);

    statusEl.innerText = `Fetching ${cardNames.length} cards...`;
    const tokenCounts = {}; const tokenIds = new Set(); const batches = [];
    while(cardNames.length > 0) batches.push(cardNames.splice(0, 75));

    try {
        for(let batch of batches) {
            const resp = await fetch("https://api.scryfall.com/cards/collection", {
                method: "POST", headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ identifiers: batch.map(name => ({ name })) })
            });
            const data = await resp.json();
            data.data.forEach(card => {
                if(card.all_parts) {
                    card.all_parts.forEach(part => {
                        if(part.component === "token") {
                            tokenIds.add(part.uri);
                            tokenCounts[part.uri] = (tokenCounts[part.uri] || 0) + 1;
                        }
                    });
                }
            });
        }
        if(tokenIds.size === 0) { statusEl.innerText = "No tokens found."; return; }
        statusEl.innerText = `Loading ${tokenIds.size} tokens...`;
        const newTokenList = {};
        for(let uri of tokenIds) {
            const tokenResp = await fetch(uri);
            const t = await tokenResp.json();

            let color = "colorless";
            if(t.colors && t.colors.length > 0) color = (t.colors.length > 1) ? "gold" : ({ 'W':'white', 'U':'blue', 'B':'black', 'R':'red', 'G':'green' }[t.colors[0]] || "colorless");

            const key = t.name.toLowerCase().replace(/\s/g, "_");
            newTokenList[key] = {
                name: t.name, color: color,
                power: parseInt(t.power)||0, toughness: parseInt(t.toughness)||1,
                imagePath: `${t.name}.png`,
                scryfallUrl: null,
                frequency: tokenCounts[uri] || 0
            };
        }
        suggestedTokens = Object.keys(newTokenList).sort((a, b) => newTokenList[b].frequency - newTokenList[a].frequency).slice(0, 4);
        activePresets = newTokenList;
        renderPresets("");
        closeDeckModal();
        alert("Deck Imported!");
    } catch (err) { console.error(err); statusEl.innerText = "Error: " + err.message; }
  }

  let tokens = [];
  let sessionImages = {};
  let selectedPreset = null;

  try { tokens = JSON.parse(localStorage.getItem("mtg_tokens")) || []; } catch { tokens = []; }

  function addTokenToBoard(newToken) {
    const getImg = (t) => sessionImages[t.id] || t.imagePath || 'none';
    const kw = (t) => (t.keywords || []).sort().join(",");
    const sig = (t) => `${t.name}|${t.color}|${t.power}|${t.toughness}|${t.counters}|${t.haste}|${t.summoning}|${t.tapped}|${getImg(t)}|${kw(t)}`;
    const match = tokens.find(t => sig(t) === sig(newToken));

    if (match) {
      match.qty += newToken.qty;
    } else {
      tokens.push(newToken);
      if (newToken.isCardCopy) { fetchTokenArt(newToken.id, newToken.name, true); }
    }
    save(); render();
  }

  function save() { localStorage.setItem("mtg_tokens", JSON.stringify(tokens)); }

  function render() {
    const list = document.getElementById("tokenList");
    const fab = document.getElementById("fabNextTurn");
    list.innerHTML = "";

    if (tokens.length > 0) fab.classList.add("visible");
    else fab.classList.remove("visible");

    tokens.forEach((t, index) => {
      const card = document.createElement("div");
      card.className = `token ${t.tapped ? 'tapped' : ''}`;
      card.dataset.color = t.color;

      // --- DOUBLE TAP LOGIC ---
      let clickTimer = null;
      let lastClickTime = 0;

      card.addEventListener("click", (e) => {
        if(e.target.tagName === "BUTTON") return;

        const currentTime = new Date().getTime();
        const timeDiff = currentTime - lastClickTime;

        if (timeDiff < 300 && timeDiff > 0) {
            // DOUBLE TAP -> Context Menu
            clearTimeout(clickTimer);
            clickTimer = null;
            lastClickTime = 0;
            showTokenContextMenu({ clientX: e.clientX, clientY: e.clientY }, t, index);
        } else {
            // SINGLE TAP -> Tap/Untap
            lastClickTime = currentTime;
            clickTimer = setTimeout(() => {
                if (t.summoning && !t.tapped) {
                    card.classList.add("shake"); setTimeout(() => card.classList.remove("shake"), 300);
                    return;
                }
                if (t.qty === 1) {
                    t.tapped = !t.tapped;
                } else {
                    t.qty--;
                    const single = JSON.parse(JSON.stringify(t));
                    single.qty = 1; single.tapped = !t.tapped; single.id = crypto.randomUUID();
                    if(sessionImages[t.id]) sessionImages[single.id] = sessionImages[t.id];
                    addTokenToBoard(single);
                    return;
                }
                save(); render();
                clickTimer = null;
            }, 250);
        }
      });

      card.addEventListener("contextmenu", (e) => { e.preventDefault(); showTokenContextMenu(e, t, index); });

      const imgContainer = document.createElement("div");
      imgContainer.className = "token-img-container";

      // 1. BACKGROUND TEXT LAYER (Always present)
      const textLayer = document.createElement("div");
      textLayer.className = "token-text-layer";
      textLayer.innerText = t.name[0];
      imgContainer.appendChild(textLayer);

      // 2. BACKGROUND IMAGE LAYER (Sits on top)
      const artLayer = document.createElement("div");
      artLayer.className = "token-art-layer";

      // Determine Image Source
      let imgUrl = "";
      if (sessionImages[t.id]) {
          imgUrl = sessionImages[t.id]; // User Upload
      } else if (t.isCardCopy && t.scryfallUrl) {
          imgUrl = t.scryfallUrl; // Real Card
      } else {
          // Default to local path.
          // Note: If this 404s, the browser just renders transparency = text shows through!
          imgUrl = t.imagePath || `${t.name}.png`;
      }

      if (imgUrl) {
          artLayer.style.backgroundImage = `url('${imgUrl}')`;
      }
      imgContainer.appendChild(artLayer);

      const effPow = t.power + t.counters;
      const effTgh = t.toughness + t.counters;
      imgContainer.innerHTML += `<div class="badge pt-badge">${effPow}/${effTgh}</div>`;
      if (t.summoning) imgContainer.innerHTML += `<div class="badge sick-badge">ZZZ</div>`;
      if (t.haste) imgContainer.innerHTML += `<div class="badge haste-badge">HASTE</div>`;

      if (t.keywords && t.keywords.length > 0) {
          const kwBadge = document.createElement("div");
          kwBadge.className = "badge keyword-badge";
          t.keywords.forEach(k => { const s = document.createElement("span"); s.innerText = k; kwBadge.appendChild(s); });
          imgContainer.appendChild(kwBadge);
      }

      card.appendChild(imgContainer);
      card.innerHTML += `<div class="token-details"><span>${t.name}</span> <span class="token-qty">x${t.qty}</span></div>`;

      const actions = document.createElement("div");
      actions.className = "token-actions";
      const btnBuff = document.createElement("button"); btnBuff.className="buff"; btnBuff.innerText="+1/+1"; btnBuff.onclick=()=>{t.counters++; save(); render();};
      const btnNerf = document.createElement("button"); btnNerf.className="nerf"; btnNerf.innerText="-1/-1"; btnNerf.onclick=()=>{t.counters--; save(); render();};
      const btnClone = document.createElement("button"); btnClone.innerText="Clone"; btnClone.onclick=()=>{
         const clone = JSON.parse(JSON.stringify(t)); clone.id=crypto.randomUUID(); clone.qty=1;
         clone.summoning = !clone.haste; clone.tapped=false; clone.counters=0;
         if(sessionImages[t.id]) sessionImages[clone.id] = sessionImages[t.id];
         addTokenToBoard(clone);
      };
      actions.append(btnBuff, btnNerf, btnClone);
      card.appendChild(actions);
      list.appendChild(card);
    });
  }

  document.getElementById("fabNextTurn").onclick = handleNextTurn;

  const ctxMenu = document.getElementById("context-menu");
  function showTokenContextMenu(e, token, index) {
    const action = token.tapped ? "Untap" : "Tap";
    ctxMenu.innerHTML = `
      <div class="menu-item" id="ctx-tap-x">${action} X...</div>
      <div class="menu-item" id="ctx-add-kw">Add Keyword...</div>
      <div class="menu-item" id="ctx-edit">Edit / Transform...</div>
      <div class="menu-item" style="color:#ff6b6b" id="ctx-kill-1">Destroy 1</div>
      <div class="menu-item" style="color:#ff6b6b" id="ctx-kill-all">Delete Stack</div>
    `;
    positionMenu(e.clientX, e.clientY);

    document.getElementById("ctx-tap-x").onclick = () => {
       const input = prompt(`How many?`, token.qty);
       if(input) {
         const count = parseInt(input);
         if(count > 0 && count < token.qty) {
            token.qty -= count;
            const newStack = JSON.parse(JSON.stringify(token));
            newStack.qty = count; newStack.tapped = !token.tapped; newStack.id = crypto.randomUUID();
            if(sessionImages[token.id]) sessionImages[newStack.id] = sessionImages[token.id];
            addTokenToBoard(newStack);
         } else if (count >= token.qty) { token.tapped = !token.tapped; save(); render(); }
       }
       ctxMenu.style.display = "none";
    };

    document.getElementById("ctx-add-kw").onclick = () => {
        const kw = prompt("Enter keyword (e.g. Flying, Shield, Trample):");
        if(kw) { if(!token.keywords) token.keywords = []; token.keywords.push(kw.toUpperCase()); save(); render(); }
        ctxMenu.style.display = "none";
    };

    document.getElementById("ctx-edit").onclick = () => {
        document.getElementById("name").value = token.name;
        document.getElementById("color").value = token.color;
        document.getElementById("power").value = token.power;
        document.getElementById("toughness").value = token.toughness;
        document.getElementById("haste").checked = token.haste;
        editingTokenId = token.id;
        document.getElementById("createBtn").innerText = "Update Token";
        document.getElementById("customContent").style.display = "block";
        document.getElementById("customArrow").innerText = "‚ñº";
        ctxMenu.style.display = "none";
    };

    document.getElementById("ctx-kill-1").onclick = () => { if(token.qty > 1) token.qty--; else triggerDelete(index); save(); render(); ctxMenu.style.display = "none"; };
    document.getElementById("ctx-kill-all").onclick = () => { triggerDelete(index); ctxMenu.style.display = "none"; };
  }

  function triggerDelete(index) {
      lastDeletedState = { tokens: JSON.parse(JSON.stringify(tokens)), images: {...sessionImages} };
      const tId = tokens[index].id;
      delete sessionImages[tId];
      tokens.splice(index, 1);
      save(); render();
      showToast("Token deleted.", () => { tokens = lastDeletedState.tokens; sessionImages = lastDeletedState.images; save(); render(); });
  }

  function positionMenu(x, y) {
    ctxMenu.style.display = "block";
    ctxMenu.style.left = `${Math.min(x, window.innerWidth - 220)}px`;
    ctxMenu.style.top = `${Math.min(y, window.innerHeight - 200)}px`;
  }

  function showPresetContextMenu(x, y, p) {
    ctxMenu.innerHTML = `<div class="menu-item" id="ctx-quick-configure">Configure... (Quantity/Stats)</div>`;
    positionMenu(x, y);
    document.getElementById("ctx-quick-configure").onclick = () => {
        document.getElementById("name").value = p.name;
        document.getElementById("color").value = p.color;
        document.getElementById("power").value = p.power;
        document.getElementById("toughness").value = p.toughness;
        selectedPreset = p;
        document.getElementById("customContent").style.display = "block";
        document.getElementById("customArrow").innerText = "‚ñº";
        document.getElementById("qty").focus();
        document.getElementById("qty").select();
        ctxMenu.style.display = "none";
    };
  }
  document.addEventListener("click", (e) => { if (!e.target.closest("#context-menu")) ctxMenu.style.display = "none"; });

  document.getElementById("tokenForm").addEventListener("submit", (e) => {
    e.preventDefault();
    const btn = document.getElementById("createBtn");
    btn.disabled = true; setTimeout(() => btn.disabled = false, 1000);

    if (editingTokenId) {
        const t = tokens.find(tk => tk.id === editingTokenId);
        if (t) {
            t.name = document.getElementById("name").value;
            t.color = document.getElementById("color").value;
            t.power = parseInt(document.getElementById("power").value)||0;
            t.toughness = parseInt(document.getElementById("toughness").value)||1;
            t.haste = document.getElementById("haste").checked;
            if (document.getElementById("isCardCopy").checked) { fetchTokenArt(t.id, t.name, true); }
        }
        editingTokenId = null;
        btn.innerText = "Create Token";
        save(); render();
        document.getElementById("name").value = "";
        toggleCustomPanel(false);
        return;
    }

    const id = crypto.randomUUID();
    const isCardCopy = document.getElementById("isCardCopy").checked;

    const newToken = {
      id,
      name: document.getElementById("name").value.trim(),
      qty: parseInt(document.getElementById("qty").value),
      color: document.getElementById("color").value,
      power: parseInt(document.getElementById("power").value)||0,
      toughness: parseInt(document.getElementById("toughness").value)||1,
      haste: document.getElementById("haste").checked,
      summoning: !document.getElementById("haste").checked,
      tapped: false, counters: 0, keywords: [],
      // SAFETY: ensure imagePath is string
      imagePath: (selectedPreset && selectedPreset.imagePath) ? selectedPreset.imagePath : null,
      scryfallUrl: (selectedPreset && selectedPreset.scryfallUrl) ? selectedPreset.scryfallUrl : null,
      isCardCopy: isCardCopy
    };

    // If user uploaded a file
    const file = document.getElementById("image").files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = () => { sessionImages[id] = reader.result; addTokenToBoard(newToken); toggleCustomPanel(false); };
      reader.readAsDataURL(file);
    } else {
      addTokenToBoard(newToken); toggleCustomPanel(false);
    }

    selectedPreset = null; // Clear preset
    document.getElementById("name").value = "";
    document.getElementById("isCardCopy").checked = false;
    document.getElementById("name").focus();
  });

  function handleNextTurn() {
    tokens.forEach(t => { t.summoning = false; t.tapped = false; });
    const consolidated = [];
    tokens.forEach(t => {
        const getImg = (token) => sessionImages[token.id] || token.imagePath || 'none';
        const kw = (token) => (token.keywords || []).sort().join(",");
        const key = `${t.name}|${t.color}|${t.power}|${t.toughness}|${t.counters}|${t.haste}|${t.summoning}|${t.tapped}|${getImg(t)}|${kw(t)}`;
        const existing = consolidated.find(c => c.key === key);
        if (existing) {
            existing.token.qty += t.qty;
            if(sessionImages[t.id] && existing.token.id !== t.id) delete sessionImages[t.id];
        } else { consolidated.push({ key, token: t }); }
    });
    tokens = consolidated.map(c => c.token);
    save(); render();
  }

  function getColorCode(c) {
    const map = { white: '#fffacd', blue: '#69c5ff', black: '#a9a9a9', red: '#ff6b6b', green: '#90ee90', colorless: '#d3d3d3', gold: '#d4af37' };
    return map[c] || '#fff';
  }

  function renderPresets(filterText = "") {
      const picker = document.getElementById("presetPicker");
      picker.innerHTML = "";
      let keys = [];
      const term = filterText.toLowerCase().trim();

      if (!term) {
          if (suggestedTokens.length > 0) { picker.style.display = "grid"; keys = suggestedTokens; }
          else { picker.style.display = "block"; picker.innerHTML = `<div style="color:#666; font-size:14px; font-style:italic; padding:20px; text-align:center;">Start typing to find tokens...</div>`; return; }
      } else {
          picker.style.display = "grid";
          keys = Object.keys(activePresets).sort().filter(key => activePresets[key].name.toLowerCase().includes(term));
      }

      if (keys.length === 0) { picker.style.display = "block"; picker.innerHTML = `<div style="color:#666; font-size:14px; padding:20px; text-align:center;">No tokens found.</div>`; return; }

      keys.forEach(key => {
        const p = activePresets[key];
        const item = document.createElement("div");
        item.className = "preset-item";
        item.innerHTML = `<div style="width:12px; height:12px; border-radius:50%; background:${getColorCode(p.color)}; border:1px solid #555;"></div> <b>${p.name}</b> <span style="color:#888; margin-left:auto; font-size:12px;">${p.power}/${p.toughness}</span>`;

        let timer = null, isLongPress = false;
        item.addEventListener("touchstart", (e) => {
            isLongPress = false; timer = setTimeout(() => { isLongPress = true; showPresetContextMenu(e.touches[0].clientX, e.touches[0].clientY, p); }, 500);
        }, {passive: true});
        item.addEventListener("touchend", (e) => { clearTimeout(timer); if(isLongPress) e.preventDefault(); });
        item.addEventListener("contextmenu", (e) => { e.preventDefault(); showPresetContextMenu(e.clientX, e.clientY, p); });

        item.onclick = () => {
          if (isLongPress) return;
          addTokenToBoard({
            id:crypto.randomUUID(), name:p.name, qty:1, color:p.color, power:p.power, toughness:p.toughness,
            haste:false, summoning:true, tapped:false, counters:0, keywords:[],
            imagePath: p.imagePath || `${p.name}.png`, scryfallUrl: p.scryfallUrl
          });
        };
        picker.appendChild(item);
      });
  }

  function toggleCustomPanel(state) {
      const content = document.getElementById("customContent");
      const arrow = document.getElementById("customArrow");
      if(state === false) { content.style.display="none"; arrow.innerText="‚ñ∂"; }
      else if(state === true) { content.style.display="block"; arrow.innerText="‚ñº"; }
      else {
          const isClosed = window.getComputedStyle(content).display === "none";
          content.style.display = isClosed ? "block" : "none";
          arrow.innerText = isClosed ? "‚ñº" : "‚ñ∂";
      }
  }
  document.getElementById("customHeader").onclick = () => toggleCustomPanel();
  document.getElementById("presetSearch").addEventListener("input", (e) => { renderPresets(e.target.value); });

  renderPresets("");
  render();
</script>
</body>
</html>